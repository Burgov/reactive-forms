{"version":3,"sources":["C:/Users/Itay/projects/opensources/reactive-forms/dist/ngneat/reactive-forms/fesm2015/ngneat-reactive-forms.js"],"names":[],"mappings":"AAAA;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0GAmdE;0JACwJ;;;;;0BAG1I","file":"ngneat-reactive-forms.js","sourcesContent":["import { FormArray as FormArray$1, FormControl as FormControl$1, FormGroup as FormGroup$1, FormBuilder as FormBuilder$1 } from '@angular/forms';\nimport { merge, defer, of, Subject, isObservable } from 'rxjs';\nimport { map, distinctUntilChanged } from 'rxjs/operators';\nimport { __decorate } from 'tslib';\nimport { ɵɵdefineInjectable, Injectable } from '@angular/core';\n\nfunction coerceArray(value) {\r\n    return Array.isArray(value) ? value : [value];\r\n}\r\nfunction isFunction(x) {\r\n    return typeof x === 'function';\r\n}\r\nfunction isNil(v) {\r\n    return v === null || v === undefined;\r\n}\n\nfunction getControlValue(control) {\r\n    if (control.getRawValue) {\r\n        return control.getRawValue();\r\n    }\r\n    return control.value;\r\n}\r\nfunction compareErrors(a, b) {\r\n    if (isNil(a) || isNil(b)) {\r\n        return a === b;\r\n    }\r\n    return JSON.stringify(a) === JSON.stringify(b);\r\n}\r\nfunction controlValueChanges$(control) {\r\n    return merge(defer(() => of(getControlValue(control))), control.valueChanges.pipe(map(() => getControlValue(control))));\r\n}\r\nfunction controlDisabled$(control) {\r\n    return merge(defer(() => of(control.disabled)), control.statusChanges.pipe(map(() => control.disabled), distinctUntilChanged()));\r\n}\r\nfunction controlEnabled$(control) {\r\n    return merge(defer(() => of(control.enabled)), control.statusChanges.pipe(map(() => control.enabled), distinctUntilChanged()));\r\n}\r\nfunction controlStatusChanges$(control) {\r\n    return merge(defer(() => of(control.status)), control.statusChanges.pipe(map(() => control.status), distinctUntilChanged()));\r\n}\r\nfunction controlErrorChanges$(control) {\r\n    return merge(defer(() => of(control.errors)), control.valueChanges.pipe(map(() => control.errors), distinctUntilChanged((a, b) => compareErrors(a, b))));\r\n}\r\nfunction enableControl(control, enabled, opts) {\r\n    if (enabled) {\r\n        control.enable(opts);\r\n    }\r\n    else {\r\n        control.disable(opts);\r\n    }\r\n}\r\nfunction disableControl(control, disabled, opts) {\r\n    enableControl(control, !disabled, opts);\r\n}\r\nfunction controlDisabledWhile(control, observable, opts) {\r\n    return observable.subscribe(isDisabled => disableControl(control, isDisabled, opts));\r\n}\r\nfunction controlEnabledWhile(control, observable, opts) {\r\n    return observable.subscribe(isEnabled => enableControl(control, isEnabled, opts));\r\n}\r\nfunction mergeControlValidators(control, validators) {\r\n    control.setValidators([control.validator, ...coerceArray(validators)]);\r\n    control.updateValueAndValidity();\r\n}\r\nfunction validateControlOn(control, validation) {\r\n    return validation.subscribe(maybeError => {\r\n        control.setErrors(maybeError);\r\n    });\r\n}\r\nfunction hasErrorAndTouched(control, error, path) {\r\n    const hasError = control.hasError(error, !path || path.length === 0 ? undefined : path);\r\n    return hasError && control.touched;\r\n}\r\nfunction hasErrorAndDirty(control, error, path) {\r\n    const hasError = control.hasError(error, !path || path.length === 0 ? undefined : path);\r\n    return hasError && control.dirty;\r\n}\r\nfunction markAllDirty(control) {\r\n    control.markAsDirty({ onlySelf: true });\r\n    control._forEachChild(control => control.markAllAsDirty());\r\n}\r\nfunction selectControlValue$(control, mapFn) {\r\n    return control.value$.pipe(map(mapFn), distinctUntilChanged());\r\n}\n\nclass FormArray extends FormArray$1 {\r\n    constructor(controls, validatorOrOpts, asyncValidator) {\r\n        super(controls, validatorOrOpts, asyncValidator);\r\n        this.controls = controls;\r\n        this.touchChanges = new Subject();\r\n        this.dirtyChanges = new Subject();\r\n        this.touch$ = this.touchChanges.asObservable().pipe(distinctUntilChanged());\r\n        this.dirty$ = this.dirtyChanges.asObservable().pipe(distinctUntilChanged());\r\n        this.value$ = controlValueChanges$(this);\r\n        this.disabledChanges$ = controlDisabled$(this);\r\n        this.enabledChanges$ = controlEnabled$(this);\r\n        this.statusChanges$ = controlStatusChanges$(this);\r\n        this.errorChanges$ = controlErrorChanges$(this);\r\n    }\r\n    select(mapFn) {\r\n        return this.value$.pipe(map(mapFn), distinctUntilChanged());\r\n    }\r\n    getRawValue() {\r\n        return super.getRawValue();\r\n    }\r\n    at(index) {\r\n        return super.at(index);\r\n    }\r\n    setValue(valueOrObservable, options) {\r\n        if (isObservable(valueOrObservable)) {\r\n            return valueOrObservable.subscribe(value => super.setValue(value, options));\r\n        }\r\n        else {\r\n            super.setValue(valueOrObservable, options);\r\n        }\r\n    }\r\n    patchValue(valueOrObservable, options) {\r\n        if (isObservable(valueOrObservable)) {\r\n            return valueOrObservable.subscribe(value => super.patchValue(value, options));\r\n        }\r\n        else {\r\n            let value = valueOrObservable;\r\n            if (isFunction(valueOrObservable)) {\r\n                value = valueOrObservable(this.value);\r\n            }\r\n            super.patchValue(value, options);\r\n        }\r\n    }\r\n    push(control) {\r\n        return super.push(control);\r\n    }\r\n    insert(index, control) {\r\n        return super.insert(index, control);\r\n    }\r\n    setControl(index, control) {\r\n        return super.setControl(index, control);\r\n    }\r\n    disabledWhile(observable, options) {\r\n        return controlDisabledWhile(this, observable, options);\r\n    }\r\n    enabledWhile(observable, options) {\r\n        return controlEnabledWhile(this, observable, options);\r\n    }\r\n    mergeValidators(validators) {\r\n        mergeControlValidators(this, validators);\r\n    }\r\n    mergeAsyncValidators(validators) {\r\n        this.setAsyncValidators([this.asyncValidator, ...coerceArray(validators)]);\r\n        this.updateValueAndValidity();\r\n    }\r\n    markAsTouched(opts) {\r\n        super.markAsTouched(opts);\r\n        this.touchChanges.next(true);\r\n    }\r\n    markAsUntouched(opts) {\r\n        super.markAsUntouched(opts);\r\n        this.touchChanges.next(false);\r\n    }\r\n    markAsPristine(opts) {\r\n        super.markAsPristine(opts);\r\n        this.dirtyChanges.next(false);\r\n    }\r\n    markAsDirty(opts) {\r\n        super.markAsDirty(opts);\r\n        this.dirtyChanges.next(true);\r\n    }\r\n    markAllAsDirty() {\r\n        markAllDirty(this);\r\n    }\r\n    reset(value, options) {\r\n        super.reset(value, options);\r\n    }\r\n    setValidators(newValidator) {\r\n        super.setValidators(newValidator);\r\n        super.updateValueAndValidity();\r\n    }\r\n    setAsyncValidators(newValidator) {\r\n        super.setAsyncValidators(newValidator);\r\n        super.updateValueAndValidity();\r\n    }\r\n    validateOn(observableValidation) {\r\n        return observableValidation.subscribe(maybeError => {\r\n            this.setErrors(maybeError);\r\n        });\r\n    }\r\n    hasError(errorCode, path) {\r\n        return super.hasError(errorCode, path);\r\n    }\r\n    setErrors(errors, opts = {}) {\r\n        return super.setErrors(errors, opts);\r\n    }\r\n    getError(errorCode, path) {\r\n        return super.getError(errorCode, path);\r\n    }\r\n    hasErrorAndTouched(errorCode, path) {\r\n        return hasErrorAndTouched(this, errorCode, path);\r\n    }\r\n    hasErrorAndDirty(errorCode, path) {\r\n        return hasErrorAndDirty(this, errorCode, path);\r\n    }\r\n    setEnable(enable = true, opts) {\r\n        enableControl(this, enable, opts);\r\n    }\r\n    setDisable(disable = true, opts) {\r\n        disableControl(this, disable, opts);\r\n    }\r\n}\n\nclass FormControl extends FormControl$1 {\r\n    constructor(formState, validatorOrOpts, asyncValidator) {\r\n        super(formState, validatorOrOpts, asyncValidator);\r\n        this.touchChanges = new Subject();\r\n        this.dirtyChanges = new Subject();\r\n        this.touch$ = this.touchChanges.asObservable().pipe(distinctUntilChanged());\r\n        this.dirty$ = this.dirtyChanges.asObservable().pipe(distinctUntilChanged());\r\n        this.value$ = controlValueChanges$(this);\r\n        this.disabled$ = controlDisabled$(this);\r\n        this.enabled$ = controlEnabled$(this);\r\n        this.status$ = controlStatusChanges$(this);\r\n        this.errors$ = controlErrorChanges$(this);\r\n    }\r\n    select(mapFn) {\r\n        return selectControlValue$(this, mapFn);\r\n    }\r\n    setValue(valueOrObservable, options) {\r\n        if (isObservable(valueOrObservable)) {\r\n            return valueOrObservable.subscribe(value => super.setValue(value, options));\r\n        }\r\n        else {\r\n            super.setValue(valueOrObservable, options);\r\n        }\r\n    }\r\n    patchValue(valueOrObservable, options) {\r\n        if (isObservable(valueOrObservable)) {\r\n            return valueOrObservable.subscribe(value => super.patchValue(value, options));\r\n        }\r\n        else {\r\n            let value = valueOrObservable;\r\n            if (isFunction(valueOrObservable)) {\r\n                value = valueOrObservable(this.value);\r\n            }\r\n            super.patchValue(value, options);\r\n        }\r\n    }\r\n    disabledWhile(observable, options) {\r\n        return controlDisabledWhile(this, observable, options);\r\n    }\r\n    enabledWhile(observable, options) {\r\n        return controlEnabledWhile(this, observable, options);\r\n    }\r\n    mergeValidators(validators) {\r\n        mergeControlValidators(this, validators);\r\n    }\r\n    mergeAsyncValidators(validators) {\r\n        this.setAsyncValidators([this.asyncValidator, ...coerceArray(validators)]);\r\n        this.updateValueAndValidity();\r\n    }\r\n    markAsTouched(opts) {\r\n        super.markAsTouched(opts);\r\n        this.touchChanges.next(true);\r\n    }\r\n    markAsUntouched(opts) {\r\n        super.markAsUntouched(opts);\r\n        this.touchChanges.next(false);\r\n    }\r\n    markAsPristine(opts) {\r\n        super.markAsPristine(opts);\r\n        this.dirtyChanges.next(false);\r\n    }\r\n    markAsDirty(opts) {\r\n        super.markAsDirty(opts);\r\n        this.dirtyChanges.next(true);\r\n    }\r\n    markAllAsDirty() {\r\n        this.markAsDirty({ onlySelf: true });\r\n    }\r\n    reset(formState, options) {\r\n        super.reset(formState, options);\r\n    }\r\n    setValidators(newValidator) {\r\n        super.setValidators(newValidator);\r\n        super.updateValueAndValidity();\r\n    }\r\n    setAsyncValidators(newValidator) {\r\n        super.setAsyncValidators(newValidator);\r\n        super.updateValueAndValidity();\r\n    }\r\n    validateOn(observableValidation) {\r\n        return validateControlOn(this, observableValidation);\r\n    }\r\n    getError(errorCode) {\r\n        return super.getError(errorCode);\r\n    }\r\n    hasError(errorCode) {\r\n        return super.hasError(errorCode);\r\n    }\r\n    setErrors(errors, opts = {}) {\r\n        return super.setErrors(errors, opts);\r\n    }\r\n    hasErrorAndTouched(error) {\r\n        return hasErrorAndTouched(this, error);\r\n    }\r\n    hasErrorAndDirty(error) {\r\n        return hasErrorAndDirty(this, error);\r\n    }\r\n    setEnable(enable = true, opts) {\r\n        enableControl(this, enable, opts);\r\n    }\r\n    setDisable(disable = true, opts) {\r\n        disableControl(this, disable, opts);\r\n    }\r\n}\n\nclass FormGroup extends FormGroup$1 {\r\n    constructor(controls, validatorOrOpts, asyncValidator) {\r\n        super(controls, validatorOrOpts, asyncValidator);\r\n        this.controls = controls;\r\n        this.touchChanges = new Subject();\r\n        this.dirtyChanges = new Subject();\r\n        this.touch$ = this.touchChanges.asObservable().pipe(distinctUntilChanged());\r\n        this.dirty$ = this.dirtyChanges.asObservable().pipe(distinctUntilChanged());\r\n        this.value$ = controlValueChanges$(this);\r\n        this.disabled$ = controlDisabled$(this);\r\n        this.enabled$ = controlEnabled$(this);\r\n        this.status$ = controlStatusChanges$(this);\r\n        this.errors$ = controlErrorChanges$(this);\r\n    }\r\n    select(mapFn) {\r\n        return selectControlValue$(this, mapFn);\r\n    }\r\n    getRawValue() {\r\n        return super.getRawValue();\r\n    }\r\n    get(path) {\r\n        return super.get(path);\r\n    }\r\n    getControl(...names) {\r\n        return this.get(names.join('.'));\r\n    }\r\n    addControl(name, control) {\r\n        super.addControl(name, control);\r\n    }\r\n    removeControl(name) {\r\n        super.removeControl(name);\r\n    }\r\n    contains(controlName) {\r\n        return super.contains(controlName);\r\n    }\r\n    setControl(name, control) {\r\n        super.setControl(name, control);\r\n    }\r\n    setValue(valueOrObservable, options) {\r\n        if (isObservable(valueOrObservable)) {\r\n            return valueOrObservable.subscribe(value => super.setValue(value, options));\r\n        }\r\n        else {\r\n            super.setValue(valueOrObservable, options);\r\n        }\r\n    }\r\n    patchValue(valueOrObservable, options) {\r\n        if (isObservable(valueOrObservable)) {\r\n            return valueOrObservable.subscribe(value => super.patchValue(value, options));\r\n        }\r\n        else {\r\n            let value = valueOrObservable;\r\n            if (isFunction(valueOrObservable)) {\r\n                value = valueOrObservable(this.value);\r\n            }\r\n            super.patchValue(value, options);\r\n        }\r\n    }\r\n    disabledWhile(observable, options) {\r\n        return controlDisabledWhile(this, observable, options);\r\n    }\r\n    enabledWhile(observable, options) {\r\n        return controlEnabledWhile(this, observable, options);\r\n    }\r\n    mergeValidators(validators) {\r\n        mergeControlValidators(this, validators);\r\n    }\r\n    mergeAsyncValidators(validators) {\r\n        this.setAsyncValidators([this.asyncValidator, ...coerceArray(validators)]);\r\n        this.updateValueAndValidity();\r\n    }\r\n    markAsTouched(opts) {\r\n        super.markAsTouched(opts);\r\n        this.touchChanges.next(true);\r\n    }\r\n    markAsUntouched(opts) {\r\n        super.markAsUntouched(opts);\r\n        this.touchChanges.next(false);\r\n    }\r\n    markAsPristine(opts) {\r\n        super.markAsPristine(opts);\r\n        this.dirtyChanges.next(false);\r\n    }\r\n    markAsDirty(opts) {\r\n        super.markAsDirty(opts);\r\n        this.dirtyChanges.next(true);\r\n    }\r\n    markAllAsDirty() {\r\n        markAllDirty(this);\r\n    }\r\n    reset(formState, options) {\r\n        super.reset(formState, options);\r\n    }\r\n    setValidators(newValidator) {\r\n        super.setValidators(newValidator);\r\n        super.updateValueAndValidity();\r\n    }\r\n    setAsyncValidators(newValidator) {\r\n        super.setAsyncValidators(newValidator);\r\n        super.updateValueAndValidity();\r\n    }\r\n    validateOn(observableValidation) {\r\n        return validateControlOn(this, observableValidation);\r\n    }\r\n    hasError(errorCode, path) {\r\n        return super.hasError(errorCode, path);\r\n    }\r\n    setErrors(errors, opts = {}) {\r\n        return super.setErrors(errors, opts);\r\n    }\r\n    getError(errorCode, path) {\r\n        return super.getError(errorCode, path);\r\n    }\r\n    hasErrorAndTouched(error, ...path) {\r\n        return hasErrorAndTouched(this, error, ...path);\r\n    }\r\n    hasErrorAndDirty(error, ...path) {\r\n        return hasErrorAndDirty(this, error, ...path);\r\n    }\r\n    setEnable(enable = true, opts) {\r\n        enableControl(this, enable, opts);\r\n    }\r\n    setDisable(disable = true, opts) {\r\n        disableControl(this, disable, opts);\r\n    }\r\n}\n\nfunction isAbstractControlOptions(options) {\r\n    return (options.asyncValidators !== undefined ||\r\n        options.validators !== undefined ||\r\n        options.updateOn !== undefined);\r\n}\r\nlet FormBuilder = class FormBuilder extends FormBuilder$1 {\r\n    group(controlsConfig, options) {\r\n        const controls = this._reduceControls(controlsConfig);\r\n        let validators = null;\r\n        let asyncValidators = null;\r\n        let updateOn;\r\n        if (options != null) {\r\n            if (isAbstractControlOptions(options)) {\r\n                validators = options.validators != null ? options.validators : null;\r\n                asyncValidators = options.asyncValidators != null ? options.asyncValidators : null;\r\n                updateOn = options.updateOn != null ? options.updateOn : undefined;\r\n            }\r\n            else {\r\n                // `options` are legacy form group options\r\n                validators = options['validator'] != null ? options['validator'] : null;\r\n                asyncValidators = options['asyncValidator'] != null ? options['asyncValidator'] : null;\r\n            }\r\n        }\r\n        // Todo: dan remove the any\r\n        return new FormGroup(controls, { asyncValidators, updateOn, validators });\r\n    }\r\n    control(formState, validatorOrOpts, asyncValidator) {\r\n        return new FormControl(formState, validatorOrOpts, asyncValidator);\r\n    }\r\n    array(controlsConfig, validatorOrOpts, asyncValidator) {\r\n        const controls = controlsConfig.map(c => this._createControl(c));\r\n        return new FormArray(controls, validatorOrOpts, asyncValidator);\r\n    }\r\n};\r\nFormBuilder.ɵprov = ɵɵdefineInjectable({ factory: function FormBuilder_Factory() { return new FormBuilder(); }, token: FormBuilder, providedIn: \"root\" });\r\nFormBuilder = __decorate([\r\n    Injectable({ providedIn: 'root' })\r\n], FormBuilder);\n\nclass ControlValueAccessor {\r\n    constructor() {\r\n        this.onChange = (value) => { };\r\n        this.onTouched = () => { };\r\n    }\r\n    registerOnChange(fn) {\r\n        this.onChange = fn;\r\n    }\r\n    registerOnTouched(fn) {\r\n        this.onTouched = fn;\r\n    }\r\n}\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ControlValueAccessor, FormArray, FormBuilder, FormControl, FormGroup };\n"]}